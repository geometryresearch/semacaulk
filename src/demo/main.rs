use ark_bn254::{Bn254, Fq, Fr, G1Affine, G2Affine};
use ark_ff::UniformRand;
use ark_poly::{
    univariate::DensePolynomial, EvaluationDomain, GeneralEvaluationDomain, UVPolynomial,
};
use ark_std::{test_rng, Zero};
use ethers::contract::abigen;
use ethers::middleware::SignerMiddleware;
use ethers::providers::Http;
use semacaulk::accumulator::{compute_lagrange_tree, compute_zero_leaf, Accumulator};
use semacaulk::contracts::compute_signal_hash;
use semacaulk::contracts::format::proof_for_semacaulk::{format_proof, ProofForSemacaulk};
use semacaulk::contracts::tests::{setup_eth_backend, EthersClient};
use semacaulk::layouter::Layouter;
use semacaulk::mimc7::init_mimc7;
use semacaulk::prover::prover::{Prover, WitnessInput};
use semacaulk::prover::{Proof as SemacaulkProof, ProverPrecomputedData, ProvingKey, PublicData};
use semacaulk::setup::setup;
use semacaulk::verifier::Verifier as SemacaulkVerifier;
use semacaulk::{
    bn_solidity_utils::{f_to_u256, u256_to_f},
    keccak_tree::{flatten_proof, KeccakTree},
};
use std::env;
use stopwatch::Stopwatch;

abigen!(SemacaulkContract, "./src/contracts/Semacaulk.json");

type SemacaulkContract = semacaulk_contract::SemacaulkContract<
    SignerMiddleware<
        ethers::providers::Provider<Http>,
        ethers::signers::Wallet<ethers::core::k256::ecdsa::SigningKey>,
    >,
>;

pub async fn deploy_semacaulk(
    client: EthersClient,
    log_2_table_size: usize,
    ptau_filename: &str,
) -> (
    SemacaulkContract,
    Accumulator<Bn254>,
    Vec<G1Affine>,
    Vec<G2Affine>,
    KeccakTree,
) {
    let zero = compute_zero_leaf::<Fr>();

    // This file is generated by https://github.com/geometryresearch/export-ptau-points
    // If you change this file, use `cargo run setup <table_size> <hex_filename> <lagrange_comms_out>` to regenerate the lagrangeCommsX file. Also remember to update Constants.sol.
    let sw = Stopwatch::start_new();
    let (pk, lagrange_comms) = setup(log_2_table_size, ptau_filename);
    let srs_g1 = pk.srs_g1;
    let srs_g2 = pk.srs_g2;

    println!("\tsetup() took {}ms", sw.elapsed_ms());

    let acc = Accumulator::<Bn254>::new(zero, &lagrange_comms);
    let empty_accumulator_x = f_to_u256::<Fq>(acc.point.x);
    let empty_accumulator_y = f_to_u256::<Fq>(acc.point.y);

    let sw = Stopwatch::start_new();
    // Construct the tree of commitments to the Lagrange bases
    let tree = compute_lagrange_tree::<Bn254>(&lagrange_comms);
    println!("\tcompute_lagrange_tree() took {}ms", sw.elapsed_ms());
    let root = tree.root();

    // Deploy contract
    let semacaulk_contract =
        SemacaulkContract::deploy(client, (root, empty_accumulator_x, empty_accumulator_y))
            .unwrap()
            .send()
            .await
            .unwrap();

    (semacaulk_contract, acc, srs_g1, srs_g2, tree)
}

#[tokio::main]
async fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        println!("Usage: demo <log_2_table_size> <ptau_filename>");
        return;
    }
    // demo <log_2_table_size> <ptau_filename>
    let _ = 1; // Change this value between builds to force the compiler to rebuild the binary properly
    let sw = Stopwatch::start_new();
    println!("Started");

    assert!(args.len() > 2);
    let log_2_table_size = &args[args.len() - 2];
    let ptau_filename = &args[args.len() - 1];

    let log_2_table_size: usize = log_2_table_size.parse().unwrap();
    let table_size = 2u64.pow(log_2_table_size as u32) as usize;
    println!("table_size: {}", table_size);

    let eth_backend = setup_eth_backend().await;
    let anvil = eth_backend.0;
    let client = eth_backend.1;
    let mut rng = test_rng();
    let mimc7 = init_mimc7::<Fr>();

    let r = deploy_semacaulk(client, log_2_table_size, ptau_filename).await;
    println!("deploy_semacaulk() took {}ms", sw.elapsed_ms());
    let semacaulk_contract = r.0;
    let mut acc = r.1;
    let srs_g1 = r.2;
    let srs_g2 = r.3;
    let tree = r.4;

    let zero = compute_zero_leaf::<Fr>();
    let mut identity_nullifiers = Vec::<Fr>::new();
    let mut identity_trapdoors = Vec::<Fr>::new();
    let mut identity_commitments: Vec<Fr> = vec![zero; table_size];
    let external_nullifier = Fr::from(1234u64);

    let signal = "signal";
    let signal_hash = compute_signal_hash(signal);
    let signal_hash_f: Fr = u256_to_f(signal_hash);

    #[allow(clippy::needless_range_loop)]
    for index in 0..1 {
        let proof = tree.proof(index).unwrap();
        let flattened_proof = flatten_proof(&proof);

        let l_i = acc.lagrange_comms[index];
        let l_i_x = f_to_u256(l_i.x);
        let l_i_y = f_to_u256(l_i.y);

        let identity_nullifier = Fr::rand(&mut rng);
        let identity_trapdoor = Fr::rand(&mut rng);
        let new_leaf = mimc7.multi_hash(&[identity_nullifier, identity_trapdoor], Fr::zero());

        identity_nullifiers.push(identity_nullifier);
        identity_trapdoors.push(identity_trapdoor);
        identity_commitments[index] = new_leaf;

        // Insert the leaf on chain
        let result = semacaulk_contract
            .insert_identity(f_to_u256(new_leaf), l_i_x, l_i_y, flattened_proof)
            .send()
            .await
            .unwrap()
            .await
            .unwrap()
            .expect("no receipt found");
        println!(
            "Gas used by insertIdentity(): {:?}",
            result.gas_used.unwrap()
        );

        // Insert the leaf off-chain
        acc.update(index, new_leaf);
    }

    // Broadcast a signal using the identity behind leaf 1
    let pk = ProvingKey::<Bn254> {
        srs_g1: srs_g1.clone(),
        srs_g2: srs_g2.clone(),
    };
    let mut rng = test_rng();

    let index = 0;
    let nullifier_hash = mimc7.multi_hash(
        &[identity_nullifiers[index], external_nullifier],
        Fr::zero(),
    );

    let assignment = Layouter::assign(
        identity_nullifiers[index],
        identity_trapdoors[index],
        external_nullifier,
        &mimc7.cts,
        &mut rng,
    );

    let domain = GeneralEvaluationDomain::<Fr>::new(table_size).unwrap();
    let c = DensePolynomial::from_coefficients_slice(&domain.ifft(&identity_commitments));

    let sw = Stopwatch::start_new();
    let precomputed = ProverPrecomputedData::index(&pk, &mimc7.cts, &[index], &c, table_size);
    println!("Precomputation took {}ms", sw.elapsed_ms());

    let sw = Stopwatch::start_new();
    let witness = WitnessInput {
        identity_nullifier: identity_nullifiers[index],
        identity_trapdoor: identity_trapdoors[index],
        identity_commitment: identity_commitments[index],
        index,
    };

    let public_input = PublicData::<Bn254> {
        accumulator: acc.point,
        external_nullifier,
        nullifier_hash,
        signal_hash: signal_hash_f,
    };

    let proof: SemacaulkProof<Bn254> = Prover::prove(
        &pk,
        &witness,
        &assignment,
        &public_input,
        &precomputed,
        &mut rng,
        table_size,
    );
    println!(
        "Proof generation (excluding precomputation) took {}ms",
        sw.elapsed_ms()
    );

    let is_valid = SemacaulkVerifier::verify(
        &proof,
        srs_g1[table_size],
        srs_g2[1],
        acc.point,
        &public_input,
    );

    println!("is_valid(): {}", is_valid);

    let result = semacaulk_contract
        .broadcast_signal(
            ethers::types::Bytes::from(String::from(signal).as_bytes().to_vec()),
            p_to_p(&format_proof(&proof)),
            f_to_u256(nullifier_hash),
            f_to_u256(external_nullifier),
        )
        .send()
        .await
        .unwrap()
        .await
        .unwrap()
        .expect("no receipt found");

    println!(
        "Gas used by broadcastSignal(): {:?}",
        result.gas_used.unwrap()
    );

    drop(anvil);
}

fn p_to_p(p: &ProofForSemacaulk) -> Proof {
    let m = MultiopenProof {
        q_1_opening: p.multiopen_proof.q_1_opening,
        q_2_opening: p.multiopen_proof.q_2_opening,
        q_3_opening: p.multiopen_proof.q_3_opening,
        q_4_opening: p.multiopen_proof.q_4_opening,
        f_cm: G1Point {
            x: p.multiopen_proof.f_cm.x,
            y: p.multiopen_proof.f_cm.y,
        },
        final_poly_proof: G1Point {
            x: p.multiopen_proof.final_poly_proof.x,
            y: p.multiopen_proof.final_poly_proof.y,
        },
    };

    let o = Openings {
        q_mimc: p.openings.q_mimc,
        mimc_cts: p.openings.mimc_cts,
        quotient: p.openings.quotient,
        u_prime: p.openings.u_prime,
        p_1: p.openings.p_1,
        p_2: p.openings.p_2,
        w_0_0: p.openings.w_0_0,
        w_0_1: p.openings.w_0_1,
        w_0_2: p.openings.w_0_2,
        w_1_0: p.openings.w_1_0,
        w_1_1: p.openings.w_1_1,
        w_1_2: p.openings.w_1_2,
        w_2_0: p.openings.w_2_0,
        w_2_1: p.openings.w_2_1,
        w_2_2: p.openings.w_2_2,
        key_0: p.openings.key_0,
        key_1: p.openings.key_1,
    };

    let c = Commitments {
        w_0: G1Point {
            x: p.commitments.w_0.x,
            y: p.commitments.w_0.y,
        },
        w_1: G1Point {
            x: p.commitments.w_1.x,
            y: p.commitments.w_1.y,
        },
        w_2: G1Point {
            x: p.commitments.w_2.x,
            y: p.commitments.w_2.y,
        },
        key: G1Point {
            x: p.commitments.key.x,
            y: p.commitments.key.y,
        },
        mimc_cts: G1Point {
            x: p.commitments.mimc_cts.x,
            y: p.commitments.mimc_cts.y,
        },
        quotient: G1Point {
            x: p.commitments.quotient.x,
            y: p.commitments.quotient.y,
        },
        u_prime: G1Point {
            x: p.commitments.u_prime.x,
            y: p.commitments.u_prime.y,
        },
        zi: G1Point {
            x: p.commitments.zi.x,
            y: p.commitments.zi.y,
        },
        ci: G1Point {
            x: p.commitments.ci.x,
            y: p.commitments.ci.y,
        },
        p_1: G1Point {
            x: p.commitments.p_1.x,
            y: p.commitments.p_1.y,
        },
        p_2: G1Point {
            x: p.commitments.p_2.x,
            y: p.commitments.p_2.y,
        },
        q_mimc: G1Point {
            x: p.commitments.q_mimc.x,
            y: p.commitments.q_mimc.y,
        },
        h: G1Point {
            x: p.commitments.h.x,
            y: p.commitments.h.y,
        },
        w: G2Point {
            x_0: p.commitments.w.x_0,
            x_1: p.commitments.w.x_1,
            y_0: p.commitments.w.y_0,
            y_1: p.commitments.w.y_1,
        },
    };

    Proof {
        multiopen_proof: m,
        commitments: c,
        openings: o,
    }
}
