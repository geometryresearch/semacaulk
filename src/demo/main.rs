use stopwatch::{Stopwatch};
use std::env;
use ark_bn254::{Bn254, Fq, Fr, G1Affine, G2Affine};
use ark_poly::{
    univariate::DensePolynomial, EvaluationDomain, GeneralEvaluationDomain, UVPolynomial,
};
use ark_ff::UniformRand;
use ark_std::{test_rng, Zero};
use ethers::contract::abigen;
use ethers::middleware::SignerMiddleware;
use ethers::providers::Http;
//use ark_ec::ProjectiveCurve;
//use semacaulk::kzg::commit;
use semacaulk::prover::{ProverPrecomputedData, ProvingKey, PublicData, Proof as SemacaulkProof};
use semacaulk::prover::prover::{Prover, WitnessInput};
use semacaulk::layouter::Layouter;
use semacaulk::verifier::{Verifier as SemacaulkVerifier};
use semacaulk::setup::{
    load_srs_from_hex,
    load_lagrange_comms_from_file,
};
use semacaulk::contracts::format::proof_for_semacaulk::{ProofForSemacaulk, format_proof};
use semacaulk::contracts::compute_signal_hash;
use semacaulk::contracts::tests::{
    setup_eth_backend,
    EthersClient,
};
use semacaulk::mimc7::init_mimc7;
use semacaulk::accumulator::{
    compute_lagrange_tree,
    compute_zero_leaf,
    Accumulator,
};
use semacaulk::{
    bn_solidity_utils::{f_to_u256, u256_to_f},
    keccak_tree::flatten_proof,
};

abigen!(
    SemacaulkContract,
    "./src/contracts/out/Semacaulk.sol/Semacaulk.json",
);

type SemacaulkContract = semacaulk_contract::SemacaulkContract<
    SignerMiddleware<
        ethers::providers::Provider<Http>,
        ethers::signers::Wallet<ethers::core::k256::ecdsa::SigningKey>,
    >,
>;

pub async fn deploy_semacaulk(
    client: EthersClient,
    srs_hex_filename: &str,
    lagrange_comms_filename: &str,
) -> (
        SemacaulkContract, Accumulator<Bn254>, Vec<G1Affine>, Vec<G2Affine>
    ) {
    let zero = compute_zero_leaf::<Fr>();

    // This file is generated by https://github.com/geometryresearch/export-ptau-points
    // If you change this file, use `cargo run setup <table_size> <hex_filename> <lagrange_comms_out>` to regenerate the lagrangeCommsX file. Also remember to update Constants.sol.
    let sw = Stopwatch::start_new();
    let (srs_g1, srs_g2) = load_srs_from_hex(srs_hex_filename);
    println!("load_srs_from_hex() took {}ms", sw.elapsed_ms());

    let sw = Stopwatch::start_new();
    let lagrange_comms = load_lagrange_comms_from_file(lagrange_comms_filename);
    println!("load_lagrange_comms_from_file() took {}ms", sw.elapsed_ms());

    let acc = Accumulator::<Bn254>::new(zero, &lagrange_comms);
    let empty_accumulator_x = f_to_u256::<Fq>(acc.point.x);
    let empty_accumulator_y = f_to_u256::<Fq>(acc.point.y);

    let sw = Stopwatch::start_new();
    // Construct the tree of commitments to the Lagrange bases
    let tree = compute_lagrange_tree::<Bn254>(&lagrange_comms);
    println!("load_lagrange_comms_from_file() took {}ms", sw.elapsed_ms());
    let root = tree.root();

    // Deploy contract
    let semacaulk_contract =
        SemacaulkContract::deploy(client, (root, empty_accumulator_x, empty_accumulator_y))
            .unwrap()
            .send()
            .await
            .unwrap();

    (semacaulk_contract, acc, srs_g1, srs_g2)
}

#[tokio::main]
async fn main () {
    // demo <log_2_table_size> <srs_hex_filename> <lagrange_comms_filename>
    let _ = 0; // Change this value between builds to force the compiler to rebuild the binary properly
    let sw = Stopwatch::start_new();
    println!("Started");

    let args: Vec<String> = env::args().collect();
    assert!(args.len() > 3);
    let log_2_table_size = &args[args.len() - 3];
    let srs_hex_filename = &args[args.len() - 2];
    let lagrange_comms_filename = &args[args.len() - 1];

    let log_2_table_size: usize = log_2_table_size.parse().unwrap();
    let table_size = 2u64.pow(log_2_table_size as u32) as usize;
    println!("table_size: {}", table_size);

    let eth_backend = setup_eth_backend().await;
    let anvil = eth_backend.0;
    let client = eth_backend.1;
    let mut rng = test_rng();
    let mimc7 = init_mimc7::<Fr>();

    let r = deploy_semacaulk(
        client,
        srs_hex_filename,
        lagrange_comms_filename,
    ).await;
    println!("deploy_semacaulk() took {}ms", sw.elapsed_ms());
    let semacaulk_contract = r.0;
    let mut acc = r.1;
    let srs_g1 = r.2;
    let srs_g2 = r.3;

    let zero = compute_zero_leaf::<Fr>();
    let sw = Stopwatch::start_new();
    let tree = compute_lagrange_tree::<Bn254>(&acc.lagrange_comms);
    println!("compute_lagrange_tree() took {}ms", sw.elapsed_ms());
    let mut identity_nullifiers = Vec::<Fr>::new();
    let mut identity_trapdoors = Vec::<Fr>::new();
    let mut identity_commitments: Vec<Fr> = vec![zero; table_size];
    let external_nullifier = Fr::from (1234u64);

    let signal = "signal";
    let signal_hash = compute_signal_hash(signal);
    let signal_hash_f: Fr = u256_to_f(signal_hash);

    //for index in 0..tree.num_leaves() {
    for index in 0..8 {
        let proof = tree.proof(index).unwrap();
        let flattened_proof = flatten_proof(&proof);

        let l_i = acc.lagrange_comms[index];
        let l_i_x = f_to_u256(l_i.x);
        let l_i_y = f_to_u256(l_i.y);

        let identity_nullifier = Fr::rand(&mut rng);
        let identity_trapdoor = Fr::rand(&mut rng);
        let new_leaf = mimc7.multi_hash(&[identity_nullifier, identity_trapdoor], Fr::zero());

        identity_nullifiers.push(identity_nullifier);
        identity_trapdoors.push(identity_trapdoor);
        //identity_commitments.push(new_leaf);
        identity_commitments[index] = new_leaf;

        // Insert the leaf on chain
        let result = semacaulk_contract
            .insert_identity(f_to_u256(new_leaf), l_i_x, l_i_y, flattened_proof)
            .send()
            .await
            .unwrap()
            .await
            .unwrap()
            .expect("no receipt found");
        println!("Gas used by insertIdentity(): {:?}", result.gas_used.unwrap());

        // Insert the leaf off-chain
        acc.update(index, new_leaf);
    }

    // Broadcast a signal using the identity behind leaf 1
    let pk = ProvingKey::<Bn254> { srs_g1: srs_g1.clone(), srs_g2: srs_g2.clone() };
    let mut rng = test_rng();

    let index = 1;
    let nullifier_hash =
        mimc7.multi_hash(&[identity_nullifiers[index], external_nullifier], Fr::zero());

    let assignment = Layouter::assign(
        identity_nullifiers[index],
        identity_trapdoors[index],
        external_nullifier,
        &mimc7.cts,
        &mut rng,
    );

    let domain = GeneralEvaluationDomain::<Fr>::new(table_size).unwrap();
    let c = DensePolynomial::from_coefficients_slice(&domain.ifft(&identity_commitments));

    let sw = Stopwatch::start_new();
    let precomputed = ProverPrecomputedData::index(&pk, &mimc7.cts, index, &c, table_size);
    println!("Precomputation took {}ms", sw.elapsed_ms());

    let sw = Stopwatch::start_new();
    let witness = WitnessInput {
        identity_nullifier: identity_nullifiers[index],
        identity_trapdoor: identity_trapdoors[index],
        identity_commitment: identity_commitments[index],
        index,
    };

    let public_input = PublicData::<Bn254> {
        accumulator: acc.point,
        external_nullifier,
        nullifier_hash,
        signal_hash: signal_hash_f,
    };

    let proof: SemacaulkProof<Bn254> = Prover::prove(
        &pk,
        &witness,
        &assignment,
        &public_input,
        &precomputed,
        &mut rng,
        table_size,
    );
    println!("Proof generation (excluding precomputation) took {}ms", sw.elapsed_ms());

    let is_valid = SemacaulkVerifier::verify(
        &proof,
        srs_g1[table_size].clone(),
        srs_g2[1].clone(),
        acc.point,
        &public_input,
    );

    println!("{}", is_valid);

    let result = semacaulk_contract
        .broadcast_signal(
            ethers::types::Bytes::from(String::from(signal).as_bytes().to_vec()),
            p_to_p(&format_proof(&proof)),
            f_to_u256(nullifier_hash),
            f_to_u256(external_nullifier),
        )
        .send()
        .await
        .unwrap()
        .await
        .unwrap()
        .expect("no receipt found");

    println!(
        "Gas used by broadcastSignal(): {:?}",
        result.gas_used.unwrap()
    );

    drop(anvil);
}

fn p_to_p(p: &ProofForSemacaulk) -> Proof {
    let m = MultiopenProof {
        q_1_opening: p.multiopen_proof.q_1_opening,
        q_2_opening: p.multiopen_proof.q_2_opening,
        q_3_opening: p.multiopen_proof.q_3_opening,
        q_4_opening: p.multiopen_proof.q_4_opening,
        f_cm: G1Point {
            x: p.multiopen_proof.f_cm.x,
            y: p.multiopen_proof.f_cm.y,
        },
        final_poly_proof: G1Point {
            x: p.multiopen_proof.final_poly_proof.x,
            y: p.multiopen_proof.final_poly_proof.y,
        },
    };

    let o = Openings {
        q_mimc: p.openings.q_mimc,
        c: p.openings.c,
        quotient: p.openings.quotient,
        u_prime: p.openings.u_prime,
        p_1: p.openings.p_1,
        p_2: p.openings.p_2,
        w_0_0: p.openings.w_0_0,
        w_0_1: p.openings.w_0_1,
        w_0_2: p.openings.w_0_2,
        w_1_0: p.openings.w_1_0,
        w_1_1: p.openings.w_1_1,
        w_1_2: p.openings.w_1_2,
        w_2_0: p.openings.w_2_0,
        w_2_1: p.openings.w_2_1,
        w_2_2: p.openings.w_2_2,
        key_0: p.openings.key_0,
        key_1: p.openings.key_1,
    };

    let c = Commitments {
        w_0: G1Point {
            x: p.commitments.w_0.x,
            y: p.commitments.w_0.y,
        },
        w_1: G1Point  {
            x: p.commitments.w_1.x,
            y: p.commitments.w_1.y,
        },
        w_2: G1Point  {
            x: p.commitments.w_2.x,
            y: p.commitments.w_2.y,
        },
        key: G1Point  {
            x: p.commitments.key.x,
            y: p.commitments.key.y,
        },
        c: G1Point  {
            x: p.commitments.c.x,
            y: p.commitments.c.y,
        },
        quotient: G1Point  {
            x: p.commitments.quotient.x,
            y: p.commitments.quotient.y,
        },
        u_prime: G1Point  {
            x: p.commitments.u_prime.x,
            y: p.commitments.u_prime.y,
        },
        zi: G1Point  {
            x: p.commitments.zi.x,
            y: p.commitments.zi.y,
        },
        ci: G1Point  {
            x: p.commitments.ci.x,
            y: p.commitments.ci.y,
        },
        p_1: G1Point  {
            x: p.commitments.p_1.x,
            y: p.commitments.p_1.y,
        },
        p_2: G1Point  {
            x: p.commitments.p_2.x,
            y: p.commitments.p_2.y,
        },
        q_mimc: G1Point  {
            x: p.commitments.q_mimc.x,
            y: p.commitments.q_mimc.y,
        },
        h: G1Point  {
            x: p.commitments.h.x,
            y: p.commitments.h.y,
        },
        w: G2Point  {
            x_0: p.commitments.w.x_0,
            x_1: p.commitments.w.x_1,
            y_0: p.commitments.w.y_0,
            y_1: p.commitments.w.y_1,
        },
    };

    Proof {
        multiopen_proof: m,
        commitments: c,
        openings: o,
    }
}
